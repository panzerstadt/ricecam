{"version":3,"sources":["components/Camera/Show.module.css","logo.svg","components/customHooks/useInterval.js","components/Camera/Camera.js","components/Camera/index.js","components/Database/lib/firebase.js","components/Database/index.js","components/MediaRecorder/index.js","components/MediaRecorder/VideoRecorder.js","components/BrightnessPredictor/helpers/index.js","components/BrightnessPredictor/index.js","components/BrightnessPredictor/BrightnessDetector.js","components/RiceCam/index.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","gallery","__webpack_require__","p","useInterval","callback","delay","savedCallback","useRef","useEffect","current","id","setInterval","clearInterval","SETTINGS","width","height","facingMode","WebcamComponent","_ref","onRef","webcamRef","_useState","useState","_useState2","Object","slicedToArray","cameraReady","setCameraReady","setupCamera","_ref2","asyncToGenerator","regenerator_default","a","mark","_callee","e1","wrap","_context","prev","next","navigator","mediaDevices","getUserMedia","_this","setState","error_messages","video","onloadedmetadata","stop","apply","this","arguments","react_default","createElement","react_webcam_default","audio","ref","screenshotFormat","videoConstraints","Camera","config","apiKey","process","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","reactConfig","keys","map","v","concat","firebase","apps","length","initializeApp","console","log","dayjs","locale","logging","message","timestamp","format","daystamp","firestore","collection","doc","set","merge","then","catch","e","activityMonitor","convertToObject","browserStorage","estimate","mem","ram","connection","connectionSpeed","battery","batteryLevel","performance","output","input","showFunction","obj","storage","sent","usage","quota","percent","toFixed","window","memory","deviceMemory","mozConnection","webkitConnection","msConnection","effectiveType","getBattery","level","network","browserMemory","objectSpread","totalJSHeapSize","jsHeapSizeLimit","comment","status","_x","grabListOfVideoPaths","_ref3","_callee4","day","_context4","get","_ref4","_callee3","querySnapshot","_context3","forEach","_ref5","_callee2","url","_context2","data","push","getDownloadURL","_x4","abrupt","Promise","all","_x3","_x2","Record","videoRef","triggerRecording","duration","onComplete","showPreview","OPTIONS","videoOut","setVideoOut","_useState3","_useState4","recordDuration","setRecordDuration","_useState5","_useState6","isRecording","_useState7","_useState8","_useState9","_useState10","videoChunk","setVideoChunk","record","makeLink","blob","Blob","type","URL","createObjectURL","out","key","controls","src","href","download","toConsumableArray","stream","active","recorder","MediaRecorder","ondataavailable","onstart","setTimeout","start","style","display","listStyleType","overflowX","loadModel","tf","predictBrightness","rgbarray","model","xs","Array","from","inputXS","preds","predict","print","arraySync","isBright","canvas","clrs","flat","res","getContext","getImageData","BrightnessDetector","isDetecting","onDetect","detectionDelay","setDetectionDelay","detect","bright","document","drawImage","PhotoStream","streamDelay","isStreaming","videoWidth","videoHeight","toDataURL","toBlob","b","imgBlob","put","location","path","err","JSON","stringify","pushImageDataToStorage","isWithinTimeRange","end","sH","slice","sM","startTimestamp","hour","minute","eH","eM","endTimestamp","chk1","isAfter","chk2","isBefore","VideoList","vlist","setVlist","names","decodeURIComponent","split","Fragment","whiteSpace","fontSize","overflow","i","margin","CameraComponent","_ref4$showPreviews","showPreviews","setVideoRef","logs","setLogs","_useState11","_useState12","isDay","setIsDay","handleLog","_useState13","_useState14","setIsDetecting","_useState15","_useState16","setIsRecording","_useState17","_useState18","videoDuration","setVideoDuration","_useState19","_useState20","timer","setTimer","_useState21","_useState22","isRecordingContinuously","setIsRecordingContinuously","_useState23","_useState24","cameraName","setCameraName","_useState25","_useState26","recordIntervalMin","setRecordIntervalMin","t","_useState27","_useState28","dbCommands","setDBCommands","onChange","onSnapshot","handleRecordContinuous","run","setContinuousRecording","setLocalStateMonitor","isContinuouslyRecording","mins","amount","time","timerStart","timerEnd","isTimerSet","videoDurationSec","videoRecordFreqMin","_useState29","nextRecordingTime","_useState30","localStateMonitor","currentState","_useState31","_useState32","_useState33","_useState34","setIsStreaming","debugStreamImages","_useState35","_useState36","isShowingDebug","toggleIsShowingDebug","backgroundColor","components_Camera","color","padding","fontWeight","onClick","target","value","RiceCam_VideoList","marginBottom","components_MediaRecorder","vidBlob","namePrefix","undefined","l","pushVideoDataToStorage","RiceCam_PhotoStream","BrightnessPredictor","App","className","RiceCam","Component","Boolean","hostname","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.13f6fc83.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"gallery\":\"Show_gallery__2fRZI\"};","module.exports = __webpack_public_path__ + \"static/media/logo.ee7cd8ed.svg\";","import React, { useState, useEffect, useRef } from \"react\";\r\n\r\nconst useInterval = (callback, delay) => {\r\n  const savedCallback = useRef();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n};\r\n\r\nexport default useInterval;\r\n","import React, { useState, useEffect, useRef } from \"react\";\r\nimport Webcam from \"react-webcam\";\r\n\r\nconst SETTINGS = {\r\n  width: 1080,\r\n  height: 1080,\r\n  facingMode: \"environment\"\r\n};\r\n\r\nconst WebcamComponent = ({ onRef }) => {\r\n  const webcamRef = useRef();\r\n  const [cameraReady, setCameraReady] = useState(false);\r\n  const setupCamera = async () => {\r\n    // MDN: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices\r\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n      const e1 =\r\n        \"Browser API navigator.mediaDevices.getUserMedia not available\";\r\n      this.setState({ error_messages: e1 });\r\n      throw e1;\r\n    }\r\n\r\n    const video = webcamRef.current.video;\r\n    video.onloadedmetadata = () => {\r\n      setCameraReady(true);\r\n    };\r\n  };\r\n\r\n  useEffect(() => {\r\n    setupCamera();\r\n  }, [webcamRef]);\r\n\r\n  if (cameraReady) {\r\n    onRef && onRef(webcamRef);\r\n  }\r\n\r\n  return (\r\n    <Webcam\r\n      audio={false}\r\n      ref={webcamRef}\r\n      screenshotFormat=\"image/jpeg\"\r\n      videoConstraints={SETTINGS}\r\n      height={400}\r\n      width={400}\r\n    />\r\n  );\r\n};\r\n\r\nexport default WebcamComponent;\r\n","import Camera from \"./Camera\";\r\nimport Show from \"./Show\";\r\n\r\nexport default Camera;\r\nexport const Gallery = Show;\r\n","import firebase from \"firebase\";\r\n\r\nconst config = {\r\n  apiKey: process.env.apiKey,\r\n  authDomain: process.env.authDomain,\r\n  databaseURL: process.env.databaseURL,\r\n  projectId: process.env.projectId,\r\n  storageBucket: process.env.storageBucket,\r\n  messagingSenderId: process.env.messagingSenderId,\r\n};\r\n\r\nconst reactConfig = {};\r\nObject.keys(config).map((v) => {\r\n  reactConfig[v] = process.env[`REACT_APP_${v}`];\r\n});\r\n\r\nif (!firebase.apps.length) {\r\n  firebase.initializeApp(reactConfig);\r\n  console.log(\"DATABASE CONNECTED.\");\r\n}\r\n\r\nexport default firebase;\r\n//module.exports = firebase;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport firebase from \"./lib/firebase\";\r\n\r\n// timestamps\r\nimport dayjs from \"dayjs\";\r\nimport \"dayjs/locale/ja\";\r\ndayjs.locale(\"ja\");\r\n\r\nexport default firebase;\r\n\r\nconst PushToFirebase = (databaseRef = \"test\", data, callback) => {\r\n  firebase\r\n    .database()\r\n    .ref(databaseRef)\r\n    .push(data)\r\n    .then((v) => callback(v));\r\n};\r\n\r\nconst PushToFirestore = (databaseRef = \"test\", data, callback) => {\r\n  const db = firebase.firestore();\r\n  db.collection(databaseRef);\r\n};\r\n\r\nconst sortTimestampArray = (data, latest = false) => {\r\n  if (latest) return data.sort((prev, next) => dayjs(next) - dayjs(prev));\r\n  // latest first\r\n  else return data.sort((prev, next) => dayjs(prev) - dayjs(next)); // earliest first\r\n};\r\n\r\nexport const logging = (message, callback) => {\r\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\r\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\r\n\r\n  firebase\r\n    .firestore()\r\n    .collection(\"logs\")\r\n    .doc(daystamp)\r\n    .collection(\"logs\")\r\n    .doc(timestamp)\r\n    .set({ message: message }, { merge: true })\r\n    .then((v) => {\r\n      callback && callback(v);\r\n    })\r\n    .catch((e) => console.log(\"LOGGING ERROR: \", e));\r\n};\r\n\r\nexport const activityMonitor = async (callback) => {\r\n  function convertToObject(input, showFunction) {\r\n    // recursively\r\n    // https://stackoverflow.com/questions/37733272/convert-dom-object-to-javascript-object\r\n    let obj = {};\r\n    for (var p in input) {\r\n      switch (typeof input[p]) {\r\n        case \"function\":\r\n          if (showFunction) obj[p] = `function: ${input[p]}`;\r\n          break;\r\n        case \"object\":\r\n          obj[p] = convertToObject(input[p], showFunction);\r\n          break;\r\n        case \"number\":\r\n          obj[p] = input[p];\r\n          break;\r\n        default:\r\n          obj[p] = input[p];\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\r\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\r\n\r\n  // browser tab storage\r\n  let browserStorage;\r\n  if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\r\n    const estimate = await navigator.storage.estimate();\r\n    browserStorage = {\r\n      usage: estimate.usage,\r\n      quota: estimate.quota,\r\n      percent: `${((estimate.usage * 100) / estimate.quota).toFixed(0)} used`,\r\n    };\r\n  } else {\r\n    browserStorage = \"browser does not have storage API\";\r\n  }\r\n  // js heap size\r\n  //   This API returns three pieces of data:\r\n  // jsHeapSizeLimit - The amount of memory (in bytes) that the JavaScript heap is limited to.\r\n  // totalJSHeapSize - The amount of memory (in bytes) that the JavaScript heap has allocated including free space.\r\n  // usedJSHeapSize - The amount of memory (in bytes) currently being used.\r\n  const mem = window.performance.memory || {};\r\n  // RAM\r\n  const ram =\r\n    `${navigator.deviceMemory} GB` ||\r\n    \"browser does not have deviceMemory API (ram)\";\r\n  // network speed\r\n  const connection =\r\n    navigator.connection ||\r\n    navigator.mozConnection ||\r\n    navigator.webkitConnection ||\r\n    navigator.msConnection;\r\n  const connectionSpeed = connection\r\n    ? connection.effectiveType\r\n    : \"browser does not have connection API\";\r\n  // battery\r\n  let battery;\r\n  if (\"getBattery\" in navigator) {\r\n    battery = await navigator.getBattery();\r\n  }\r\n  const batteryLevel = battery\r\n    ? battery.level\r\n    : \"browser does not have battery API\";\r\n  // general performance\r\n  // .toJSON() is unreliable, returns custom objects\r\n  const performance = convertToObject(window.performance, false);\r\n\r\n  const output = {\r\n    storage: browserStorage,\r\n    ram: ram,\r\n    network: connectionSpeed,\r\n    battery: batteryLevel,\r\n    performance: performance,\r\n    browserMemory: {\r\n      ...convertToObject(mem, false),\r\n      usage: `${(mem.totalJSHeapSize / mem.jsHeapSizeLimit) * 100} percent`,\r\n      comment:\r\n        \"units in bytes. percent is percent of allocated browser memory (multiple tabs included)\",\r\n    },\r\n  };\r\n\r\n  firebase\r\n    .firestore()\r\n    .collection(\"logs\")\r\n    .doc(daystamp)\r\n    .collection(\"browser performance logs\")\r\n    .doc(timestamp)\r\n    .set({ status: output }, { merge: true })\r\n    .then((v) => {\r\n      callback && callback(v);\r\n    })\r\n    .catch((e) => console.log(\"LOGGING ERROR: \", e));\r\n};\r\n\r\nexport const pushImageDataToStorage = (imgBlob) => {\r\n  const imgFolder = \"images\";\r\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\r\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\r\n\r\n  console.log(\"pushing Image blob: \", imgBlob);\r\n  firebase\r\n    .storage()\r\n    .ref(`${imgFolder}/${timestamp}.png`)\r\n    .put(imgBlob)\r\n    .then((res) => {\r\n      console.log(`image blob pushed to: ${res.ref.location.path}`, res);\r\n      const path = res.ref.location.path;\r\n      firebase\r\n        .firestore()\r\n        .collection(\"imageURL\")\r\n        .doc(daystamp)\r\n        .collection(\"urls\")\r\n        .doc()\r\n        .set({ url: path });\r\n    })\r\n    .catch((e) => {\r\n      const err = `pushImageDataToStorage: ERROR ${JSON.stringify(e)}`;\r\n      console.log(err);\r\n      logging(err);\r\n    });\r\n};\r\n\r\nexport const pushVideoDataToStorage = (vidBlob, namePrefix = \"\") => {\r\n  const vidFolder = \"videos\";\r\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\r\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\r\n\r\n  firebase\r\n    .storage()\r\n    .ref(`${vidFolder}/${namePrefix}-${timestamp}.mp4`)\r\n    .put(vidBlob)\r\n    .then((res) => {\r\n      console.log(res);\r\n      console.log(res.ref.location.path);\r\n      const path = res.ref.location.path;\r\n      firebase\r\n        .firestore()\r\n        .collection(\"videoURL\")\r\n        .doc(daystamp)\r\n        .collection(\"urls\")\r\n        .doc()\r\n        .set({ url: path })\r\n        .then((v) => {\r\n          const l = `pushVideoDataToStorage: COMPLETE video:${vidFolder}/${timestamp}.mp4, ref: ${path}, callback: ${v}`;\r\n          logging(l, () => console.log(l));\r\n        });\r\n    })\r\n    .catch((e) => {\r\n      const err = `pushVideoDataToStorage: ERROR ${JSON.stringify(e)}`;\r\n      logging(err, () => console.log(err));\r\n    });\r\n};\r\n\r\nexport const grabListOfVideoPaths = async (day) => {\r\n  const daystamp = day\r\n    ? dayjs(day).format(\"YYYY-MM-DD\")\r\n    : dayjs().format(\"YYYY-MM-DD\");\r\n\r\n  console.log(\"grabbing videos from: \", daystamp);\r\n\r\n  return await firebase\r\n    .firestore()\r\n    .collection(\"videoURL\")\r\n    .doc(daystamp)\r\n    .collection(\"urls\")\r\n    .get()\r\n    .then(async (querySnapshot) => {\r\n      let output = [];\r\n      await querySnapshot.forEach(async (doc) => {\r\n        // here are your DB video filepaths\r\n        const url = doc.data().url;\r\n        // console.log(url);\r\n\r\n        output.push(\r\n          firebase.storage().ref(url).getDownloadURL() // this is an async function\r\n        );\r\n      });\r\n      return Promise.all(output);\r\n    });\r\n};\r\n\r\n// single call\r\nexport const pullAppStateFromDB = () => {\r\n  firebase\r\n    .firestore()\r\n    .collection(\"appState\")\r\n    .doc(\"commands\")\r\n    .get()\r\n    .then((doc) => {\r\n      console.log(doc.data());\r\n    })\r\n    .catch((e) => console.log(\"REMOTE DB STATE READ ERROR: \", e));\r\n};\r\n\r\n// listener function\r\nexport const listenToDBAppState = (onChange) => {\r\n  return firebase\r\n    .firestore()\r\n    .collection(\"appState\")\r\n    .doc(\"commands\")\r\n    .onSnapshot((doc) => {\r\n      onChange && onChange(doc.data());\r\n      return doc.data();\r\n    });\r\n};\r\n// notify function\r\nexport const reportAppStatetoDB = (currentState) => {\r\n  firebase\r\n    .firestore()\r\n    .collection(\"appState\")\r\n    .doc(\"currentState\")\r\n    .set(currentState, { merge: true })\r\n    .then((v) => console.log(\"REMOTE STATE UPDATER: complete. \", v))\r\n    .catch((e) => console.log(\"REMOTE DB STATE UPDATE ERROR: \", e));\r\n};\r\n\r\nexport const FireStoreState = ({\r\n  collection = \"appState\",\r\n  doc = \"commands\",\r\n  onUpdate,\r\n}) => {\r\n  const [dbState, setDBState] = useState({});\r\n\r\n  useEffect(() => {\r\n    firebase\r\n      .collection(collection)\r\n      .doc(doc)\r\n      .onSnapshot((snapshot) => {\r\n        setDBState(snapshot.data());\r\n      });\r\n    return () => setDBState({});\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (onUpdate) onUpdate(dbState);\r\n  }, [dbState]);\r\n\r\n  return <p>db state: {JSON.stringify(dbState, null, 2)}</p>;\r\n};\r\n\r\nconst deleteImageDataFromDBRecords = () => {\r\n  // delete by timestamp based on prediction\r\n  const imgCollection = \"imageData\";\r\n};\r\n\r\nconst createVideoFromDBRecords = () => {\r\n  // pull in data from DB and construct video\r\n  const imgCollection = \"imageData\";\r\n  const predCollection = \"\";\r\n};\r\n\r\nconst getPredictionsFromDB = () => {\r\n  // predictions should return together with the references UID from imageData\r\n  // as well as timestamp\r\n  const collectionName = \"predictions\";\r\n};\r\n","import Record from \"./VideoRecorder\";\r\n\r\nexport default Record;\r\n","import React, { useState, useEffect, useRef } from \"react\";\r\nimport { logging } from \"../Database\";\r\n\r\nconst VideoRecorder = ({\r\n  videoRef,\r\n  triggerRecording,\r\n  duration,\r\n  onComplete,\r\n  showPreview\r\n}) => {\r\n  const OPTIONS = {\r\n    tag: \"video\",\r\n    type: \"video/webm\",\r\n    ext: \".mp4\",\r\n    gUM: { video: true, audio: true }\r\n  };\r\n  const [videoOut, setVideoOut] = useState(\"\");\r\n\r\n  const [recordDuration, setRecordDuration] = useState(5000);\r\n  useEffect(() => {\r\n    if (duration && typeof duration === \"number\") setRecordDuration(duration);\r\n  }, [duration]);\r\n\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [videoRecordings, setVideoRecordings] = useState([]);\r\n  const [videoChunk, setVideoChunk] = useState([]);\r\n  const ulRef = useRef();\r\n  useEffect(() => {\r\n    if (triggerRecording === true && isRecording === false) {\r\n      logging(\"VideoRecorder: START starting one recording\");\r\n      record({ duration: recordDuration });\r\n    }\r\n  }, [triggerRecording, isRecording]);\r\n\r\n  useEffect(() => {\r\n    // if there is a recording\r\n    if (videoChunk.length > 0) {\r\n      console.log(\"making link!\", videoChunk);\r\n      showPreview && makeLink();\r\n    }\r\n  }, [videoChunk]);\r\n\r\n  const makeLink = () => {\r\n    let blob = new Blob(videoChunk, { type: OPTIONS.type });\r\n\r\n    let url = URL.createObjectURL(blob);\r\n\r\n    const out = (\r\n      <li key={url}>\r\n        <video height={200} controls src={url} />\r\n        <br />\r\n        <a href={url} download={`video${OPTIONS.ext}`}>{`download ${`video${\r\n          OPTIONS.ext\r\n        }`}`}</a>\r\n      </li>\r\n    );\r\n    setVideoOut([...videoOut, out]);\r\n  };\r\n\r\n  const record = ({ duration = 2000 }) => {\r\n    if (videoRef) {\r\n      const stream = videoRef.current.stream;\r\n      if (!stream.active) {\r\n        console.log(\"media stream is not active.\", stream);\r\n      }\r\n\r\n      // setup recorder\r\n      const recorder = new MediaRecorder(stream);\r\n      recorder.ondataavailable = e => {\r\n        // when the recording is complete and there is data\r\n        setVideoChunk([e.data]);\r\n        if (onComplete) onComplete(e.data);\r\n      };\r\n      recorder.onstart = e => {\r\n        setVideoChunk([]);\r\n        setTimeout(() => {\r\n          recorder.stop();\r\n        }, recordDuration);\r\n      };\r\n\r\n      // run recorder\r\n      recorder.start();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ul\r\n      style={{\r\n        display: \"flex\",\r\n        listStyleType: \"none\",\r\n        width: \"100%\",\r\n        overflowX: \"scroll\"\r\n      }}\r\n    >\r\n      {videoOut}\r\n    </ul>\r\n  );\r\n};\r\n\r\nexport default VideoRecorder;\r\n","import * as tf from \"@tensorflow/tfjs\";\r\n\r\nconst WIDTH = 12;\r\nconst HEIGHT = 9;\r\nconst ARR_LENGTH = 432;\r\n\r\nconst loadModel = async () => {\r\n  return await tf.loadLayersModel(\"assets/model/brightness-predictor.json\");\r\n};\r\n\r\nconst predictBrightness = async rgbarray => {\r\n  const model = await loadModel();\r\n\r\n  if (model) {\r\n    return await tf.tidy(() => {\r\n      const xs = [Array.from(rgbarray)];\r\n      const inputXS = tf.tensor2d(xs, [xs.length, ARR_LENGTH]);\r\n\r\n      console.log(inputXS);\r\n\r\n      const preds = model.predict(inputXS);\r\n\r\n      preds.print();\r\n\r\n      const out = preds.arraySync()[0][0];\r\n\r\n      return out;\r\n    });\r\n  }\r\n};\r\n\r\n// sml model learning bright and dark\r\nexport const isBright = async canvas => {\r\n  const clrs = canvas\r\n    .getContext(\"2d\")\r\n    .getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n  console.log(clrs);\r\n\r\n  const flat = clrs.data;\r\n  const res = await predictBrightness(flat);\r\n  console.log(res);\r\n  return res > 0.6 ? true : false;\r\n};\r\n\r\nexport default isBright;\r\n","import BrightnessDetector from \"./BrightnessDetector\";\r\n\r\nexport default BrightnessDetector;\r\n","import { useState, useEffect } from \"react\";\r\nimport useInterval from \"../customHooks/useInterval\";\r\n\r\nimport { isBright } from \"./helpers\";\r\n\r\nconst BrightnessDetector = ({ videoRef, isDetecting, delay, onDetect }) => {\r\n  // local ML brightness detection\r\n  const [detectionDelay, setDetectionDelay] = useState(500);\r\n  useEffect(() => {\r\n    if (delay && typeof delay === \"number\") setDetectionDelay(delay);\r\n  }, [delay]);\r\n\r\n  useInterval(\r\n    () => {\r\n      detect();\r\n    },\r\n    isDetecting ? detectionDelay : null\r\n  );\r\n  const detect = async () => {\r\n    if (videoRef) {\r\n      let context;\r\n      const video = videoRef.current.video;\r\n      const canvas = document.createElement(\"canvas\");\r\n      canvas.width = 12;\r\n      canvas.height = 9;\r\n      // TODO: check if canvas is drawing entire image, or is it cut off\r\n\r\n      context = canvas.getContext(\"2d\");\r\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\r\n      // check brightness\r\n      const bright = await isBright(canvas);\r\n      if (onDetect) {\r\n        onDetect({ bright: bright });\r\n      }\r\n    }\r\n  };\r\n  return null;\r\n};\r\n\r\nexport default BrightnessDetector;\r\n","// https://ml5js.org/docs/image-classification-example\r\n// https://codelabs.developers.google.com/?cat=TensorFlow\r\n// https://console.firebase.google.com/u/3/project/operation-verde-ricecam/database\r\n\r\nimport React, { useState, useEffect } from \"react\";\r\n// timestamps\r\nimport dayjs from \"dayjs\";\r\nimport \"dayjs/locale/ja\";\r\n\r\nimport useInterval from \"../customHooks/useInterval\";\r\nimport Camera from \"../Camera\";\r\nimport VideoRecorder from \"../MediaRecorder\";\r\nimport BrightnessDetector from \"../BrightnessPredictor\";\r\nimport {\r\n  pushImageDataToStorage,\r\n  pushVideoDataToStorage,\r\n  reportAppStatetoDB,\r\n  listenToDBAppState,\r\n  grabListOfVideoPaths,\r\n  logging,\r\n  activityMonitor,\r\n} from \"../Database\";\r\n\r\nimport { download, convertToArray, convertToObject } from \"../atoms\";\r\n\r\ndayjs.locale(\"ja\");\r\nconst SCALE = 1;\r\nconst RGB_SCALE = 0.02;\r\nconst DETECT_SCALE = 0.02;\r\nconst STREAM_SCALE = 1;\r\nconst MONITOR_SCALE = 0.1;\r\n\r\nconst PhotoRecorder = ({ videoRef, captureDelay, isCapturing, onRecord }) => {\r\n  useInterval(\r\n    () => {\r\n      capture();\r\n    },\r\n    isCapturing ? captureDelay : null\r\n  );\r\n\r\n  const [data, setData] = useState([]);\r\n  const [rgb, setRGB] = useState([]);\r\n  const capture = () => {\r\n    let out = {\r\n      b64: \"\",\r\n      rgbArray: [],\r\n    };\r\n    if (videoRef) {\r\n      let context;\r\n      const video = videoRef.current.video;\r\n      const canvas = document.createElement(\"canvas\");\r\n\r\n      canvas.width = video.videoWidth * SCALE;\r\n      canvas.height = video.videoHeight * SCALE;\r\n      // canvas.width = 12;\r\n      // canvas.height = 9;\r\n\r\n      context = canvas.getContext(\"2d\");\r\n\r\n      // full res\r\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\r\n      // base64 setstate\r\n      const b64 = canvas.toDataURL();\r\n      setData([...data, b64]);\r\n      out.b64 = [...data, b64];\r\n\r\n      context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      canvas.width = video.videoWidth * RGB_SCALE;\r\n      canvas.height = video.videoHeight * RGB_SCALE;\r\n\r\n      context = canvas.getContext(\"2d\");\r\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\r\n      // rgb array (flat)\r\n      const clrs = context.getImageData(0, 0, canvas.width, canvas.height);\r\n      console.log(clrs);\r\n      const flat = convertToArray(clrs.data);\r\n\r\n      setRGB([...rgb, flat]);\r\n      out.rgbArray = [...rgb, flat];\r\n      // download(JSON.stringify({ data: flat }), \"temp.json\", \"application/json\");\r\n\r\n      onRecord && onRecord(out);\r\n\r\n      return data;\r\n    }\r\n  };\r\n\r\n  return <p>capturing: {isCapturing}</p>;\r\n};\r\n\r\nconst PhotoStream = ({ videoRef, streamDelay, isStreaming }) => {\r\n  useInterval(\r\n    () => {\r\n      stream();\r\n    },\r\n    isStreaming ? streamDelay : null\r\n  );\r\n  const stream = () => {\r\n    if (videoRef) {\r\n      let context;\r\n      const video = videoRef.current.video;\r\n      const canvas = document.createElement(\"canvas\");\r\n\r\n      canvas.width = video.videoWidth * STREAM_SCALE;\r\n      canvas.height = video.videoHeight * STREAM_SCALE;\r\n      context = canvas.getContext(\"2d\");\r\n\r\n      // full res\r\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\r\n      // preview\r\n      // base64 setstate\r\n      const b64 = canvas.toDataURL();\r\n      // setData([...data, b64]);\r\n\r\n      // blob it to send to db\r\n      // blobbing takes a long time therefore there is a callback\r\n      canvas.toBlob((b) => {\r\n        console.log(b);\r\n        pushImageDataToStorage(b);\r\n      });\r\n    }\r\n  };\r\n\r\n  return <p> DEBUG: photo streaming: {`${isStreaming}`}</p>;\r\n};\r\n\r\nconst isWithinTimeRange = (start, end) => {\r\n  console.log(start, end);\r\n  if (!start || !end) return false;\r\n  const timestamp = dayjs();\r\n  const sH = start.slice(0, 2);\r\n  const sM = start.slice(2);\r\n  const startTimestamp = dayjs().hour(sH).minute(sM);\r\n\r\n  const eH = end.slice(0, 2);\r\n  const eM = end.slice(2);\r\n  const endTimestamp = dayjs().hour(eH).minute(eM);\r\n\r\n  const chk1 = timestamp.isAfter(startTimestamp);\r\n  const chk2 = timestamp.isBefore(endTimestamp);\r\n  const res = chk1 && chk2;\r\n\r\n  return res;\r\n};\r\n\r\nconst Timer = ({ start, end, onDetect }) => {\r\n  if (!start || !end) return \"null timer\";\r\n  const timestamp = dayjs();\r\n  const sH = start.slice(0, 2);\r\n  const sM = start.slice(2);\r\n  const startTimestamp = dayjs().hour(sH).minute(sM);\r\n\r\n  const eH = end.slice(0, 2);\r\n  const eM = end.slice(2);\r\n  const endTimestamp = dayjs().hour(eH).minute(eM);\r\n\r\n  const chk1 = timestamp.isAfter(startTimestamp);\r\n  const chk2 = timestamp.isBefore(endTimestamp);\r\n  const res = chk1 && chk2;\r\n\r\n  res && onDetect && onDetect(res);\r\n\r\n  return (\r\n    <div>\r\n      <h3>timer: </h3>\r\n      <p>now: {timestamp.format(\"HH:mm\")}</p>\r\n      <p>start: {startTimestamp.format(\"HH:mm\")}</p>\r\n      <p>end: {endTimestamp.format(\"HH:mm\")}</p>\r\n      <p>recording allowed? : {`${res}`}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nconst VideoList = () => {\r\n  // list videos from db\r\n  const [vlist, setVlist] = useState([]);\r\n\r\n  useEffect(() => {\r\n    grabListOfVideoPaths().then((v) => {\r\n      setVlist(v);\r\n    });\r\n  }, []);\r\n\r\n  const names = vlist.map((v) =>\r\n    decodeURIComponent(v.split(\"/videos%2F\")[1].split(\"?alt\")[0])\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <h3>current list of videos today ({vlist.length}): </h3>\r\n      <ul\r\n        style={{\r\n          whiteSpace: \"nowrap\",\r\n          fontSize: \"0.5rem\",\r\n          listStyleType: \"none\",\r\n          height: 300,\r\n          overflow: \"scroll\",\r\n        }}\r\n      >\r\n        {vlist.map((v, i) => {\r\n          return (\r\n            <li key={i} style={{ margin: \"5px 0\" }}>\r\n              <a href={v}>{names[i]}</a>\r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n    </>\r\n  );\r\n};\r\n\r\nconst CameraComponent = ({ showPreviews = false }) => {\r\n  const [videoRef, setVideoRef] = useState();\r\n  const [logs, setLogs] = useState([]);\r\n  const [isDay, setIsDay] = useState(true);\r\n  // log messages\r\n  const handleLog = (message) => {\r\n    setLogs((prev) => [...prev.slice(-4), message]);\r\n    console.log(\"LOGGER message: \", message);\r\n    logging(message, (v) => console.log(\"LOGGER: completed. \", v));\r\n  };\r\n  // log browser status\r\n  const ACTIVITY_MONITOR_INTERVAL = 60000;\r\n  useInterval(() => {\r\n    console.log(\"logging browser performance\");\r\n    activityMonitor();\r\n  }, ACTIVITY_MONITOR_INTERVAL);\r\n\r\n  // local ML brightness detector\r\n  const [isDetecting, setIsDetecting] = useState(false);\r\n  const DELAY = 1000;\r\n\r\n  // video recorder\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [videoDuration, setVideoDuration] = useState(5000);\r\n  const [timer, setTimer] = useState({ start: null, end: null });\r\n  const [isRecordingContinuously, setIsRecordingContinuously] = useState(false);\r\n  const [cameraName, setCameraName] = useState(\"\");\r\n  const EVERY_N_MINS = 5;\r\n  const [recordIntervalMin, setRecordIntervalMin] = useState(EVERY_N_MINS);\r\n  useInterval(\r\n    () => {\r\n      const t = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\r\n\r\n      if (!isRecording && isWithinTimeRange(timer.start, timer.end)) {\r\n        handleLog(`recording video at ${t}`);\r\n        console.log(\r\n          \"within timer?? \",\r\n          isWithinTimeRange(timer.start, timer.end)\r\n        );\r\n        setIsRecording(true);\r\n      } else {\r\n        handleLog(\"recording still underway, not setting recording to true\");\r\n      }\r\n    },\r\n    isRecordingContinuously ? recordIntervalMin * 60000 : null\r\n  );\r\n\r\n  // listen to DB commands (remote)\r\n  const [dbCommands, setDBCommands] = useState({});\r\n  useEffect(() => {\r\n    if (videoRef) {\r\n      console.log(\"listening to DB!\");\r\n      listenToDBAppState(setDBCommands);\r\n    }\r\n  }, [videoRef]);\r\n  // set commands according to db\r\n  const handleSetVideoDuration = (amount) => {\r\n    handleLog(\r\n      `setting recording duration to ${dbCommands.videoDurationSec} secs`\r\n    );\r\n    setVideoDuration(amount);\r\n  };\r\n  const handleSetVideoRecordFrequency = (mins) => {\r\n    handleLog(\r\n      `setting recording interval to ${dbCommands.videoRecordFreqMin} mins`\r\n    );\r\n    setRecordIntervalMin(mins);\r\n  };\r\n  const handleSetTimer = (time) => {\r\n    handleLog(`setting timers to ${JSON.stringify(time)}`);\r\n    if (time.start && time.end) {\r\n      setLocalStateMonitor((p) => ({\r\n        ...p,\r\n        isTimerSet: true,\r\n      }));\r\n      setTimer(time);\r\n    }\r\n  };\r\n  const handleRecordOnce = (run) => {\r\n    handleLog(`recording video once`);\r\n    setLocalStateMonitor((p) => ({\r\n      ...p,\r\n      isRecording: true,\r\n    }));\r\n    setIsRecording(true);\r\n  };\r\n  const handleRecordContinuous = (run) => {\r\n    if (run) {\r\n      handleLog(\r\n        `setting continuous recording to ${dbCommands.setContinuousRecording}`\r\n      );\r\n      setLocalStateMonitor((p) => ({\r\n        ...p,\r\n        isContinuouslyRecording: true,\r\n        isRecording: true,\r\n      }));\r\n      setIsRecording(true);\r\n      setIsRecordingContinuously(true);\r\n    } else {\r\n      handleLog(\r\n        `setting continuous recording to ${dbCommands.setContinuousRecording}`\r\n      );\r\n      setLocalStateMonitor((p) => ({\r\n        ...p,\r\n        isContinuouslyRecording: false,\r\n        isRecording: false,\r\n      }));\r\n      setIsRecording(false);\r\n      setIsRecordingContinuously(false);\r\n    }\r\n  };\r\n  useEffect(() => {\r\n    if (dbCommands) {\r\n      handleLog(`commands received: ${JSON.stringify(dbCommands)}`);\r\n      if (\r\n        timer.start !== dbCommands.timerStart ||\r\n        timer.end !== dbCommands.timerEnd\r\n      ) {\r\n        handleSetTimer({\r\n          start: dbCommands.timerStart,\r\n          end: dbCommands.timerEnd,\r\n        });\r\n      }\r\n      if (isRecordingContinuously !== dbCommands.setContinuousRecording) {\r\n        handleRecordContinuous(dbCommands.setContinuousRecording);\r\n      }\r\n      if (videoDuration !== dbCommands.videoDurationSec) {\r\n        handleSetVideoDuration(dbCommands.videoDurationSec);\r\n      }\r\n      if (recordIntervalMin !== dbCommands.videoRecordFreqMin) {\r\n        handleSetVideoRecordFrequency(dbCommands.videoRecordFreqMin);\r\n      }\r\n    }\r\n  }, [dbCommands]);\r\n\r\n  // push local state to DB\r\n  const [localStateMonitor, setLocalStateMonitor] = useState({\r\n    isContinuouslyRecording: null,\r\n    isRecording: null,\r\n    isTimerSet: null,\r\n    nextRecordingTime: null,\r\n  });\r\n  useEffect(() => {\r\n    reportAppStatetoDB(localStateMonitor);\r\n  }, [localStateMonitor]);\r\n\r\n  // --------\r\n  // TESTING\r\n  // --------\r\n  // db streaming for images\r\n  const [streamDelay, setStreamDelay] = useState(100);\r\n  const [isStreaming, setIsStreaming] = useState(false);\r\n  const streamToDB = () => {\r\n    // toggle\r\n\r\n    if (!isStreaming) {\r\n      handleLog(\"streaming images to database!\");\r\n      // setStreamDelay(100);\r\n      setIsStreaming(true);\r\n    } else {\r\n      handleLog(\"image streaming stopped!\");\r\n      setIsStreaming(false);\r\n      // setStreamDelay(1000);\r\n    }\r\n  };\r\n  const handleStreamToDB = (run) => {\r\n    if (run) {\r\n      handleLog(\"DEBUG: streaming images to database!\");\r\n      // setStreamDelay(100);\r\n      setIsStreaming(true);\r\n    } else {\r\n      handleLog(\"DEBUG: stopping image stream!\");\r\n      setIsStreaming(false);\r\n    }\r\n  };\r\n  useEffect(() => {\r\n    if (dbCommands) {\r\n      if (isStreaming !== dbCommands.debugStreamImages) {\r\n        handleStreamToDB(dbCommands.debugStreamImages);\r\n      }\r\n    }\r\n  }, [dbCommands]);\r\n\r\n  // const handleRecord1Hour = () => {\r\n  //   const OneHourInMS = 3600000;\r\n  //   setIsRecording(true);\r\n  //   setIsRecordingContinuously(true);\r\n  //   setTimeout(() => {\r\n  //     setIsRecordingContinuously(false);\r\n  //   }, OneHourInMS);\r\n  // };\r\n\r\n  const handleToggleDetect = () => {\r\n    setIsDetecting(!isDetecting);\r\n  };\r\n\r\n  const handleVideoComplete = (vidBlob) => {\r\n    console.log(cameraName, vidBlob);\r\n    pushVideoDataToStorage(vidBlob, cameraName);\r\n    setLocalStateMonitor((p) => ({ ...p, isRecording: false }));\r\n    setIsRecording(false);\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (videoRef) {\r\n      const video = videoRef.current.video;\r\n      video.height = video.videoHeight * MONITOR_SCALE;\r\n      video.width = video.videoWidth * MONITOR_SCALE;\r\n      console.log(videoRef.current.video);\r\n    }\r\n  }, [videoRef]);\r\n\r\n  const [isShowingDebug, toggleIsShowingDebug] = useState(false);\r\n\r\n  return (\r\n    <div style={{ backgroundColor: isDay ? \"white\" : \"#282c34\" }}>\r\n      <Camera onRef={setVideoRef} />\r\n\r\n      <br />\r\n      {!cameraName ? (\r\n        <h3>please select a camera</h3>\r\n      ) : (\r\n        <p>\r\n          select <strong style={{ color: \"gray\" }}>'record 5 sec'</strong> to\r\n          test that the camera is recording properly.\r\n          <br />\r\n          if it does, your new video should show up on the 'current list of\r\n          videos today' section.\r\n          <br />\r\n          When you are ready, press the{\" \"}\r\n          <strong>'record 5 sec indefinitely'</strong> button.\r\n        </p>\r\n      )}\r\n\r\n      <code>recording options: </code>\r\n      <br />\r\n      <button\r\n        style={{\r\n          color: isRecording ? \"red\" : \"black\",\r\n          padding: \"5px 10px\",\r\n          fontWeight: \"bold\",\r\n        }}\r\n        onClick={handleRecordOnce}\r\n      >\r\n        record 5 sec\r\n      </button>\r\n      {/* <button onClick={handleRecord1Hour}>\r\n        record 5 sec videos for 1 hour\r\n      </button> */}\r\n      <button\r\n        onClick={handleRecordContinuous}\r\n        style={{\r\n          color: isRecordingContinuously ? \"red\" : \"black\",\r\n          padding: \"5px 10px\",\r\n          fontWeight: \"bold\",\r\n        }}\r\n      >\r\n        record 5 sec indefinitely\r\n      </button>\r\n      <select\r\n        onChange={(e) => {\r\n          console.log(e.target.value + \" selected\");\r\n          setCameraName(e.target.value);\r\n        }}\r\n        style={{\r\n          padding: \"5px 10px\",\r\n          fontWeight: \"bold\",\r\n          color: cameraName ? \"black\" : \"red\",\r\n        }}\r\n      >\r\n        <option style={{ color: \"red\" }} value=\"\">\r\n          PLEASE SELECT CAMERA\r\n        </option>\r\n        <option value=\"CAM 01\">CAM 01</option>\r\n        <option value=\"CAM 02\">CAM 02</option>\r\n      </select>\r\n      <br />\r\n      <VideoList />\r\n      <br />\r\n\r\n      <button\r\n        onClick={() => toggleIsShowingDebug((p) => !p)}\r\n        style={{ padding: \"5px 10px\", marginBottom: 30 }}\r\n      >\r\n        Toggle Show Debug\r\n      </button>\r\n\r\n      {isShowingDebug ? (\r\n        <div>\r\n          <code>debug buttons: </code>\r\n          <br />\r\n          {/* <button onClick={captureOne}>capture</button>\r\n          <button onClick={capture5sec}>capture5sec</button>\r\n          <button onClick={capture5secvideo}>capture5sec video</button>\r\n          <button onClick={downloadAsJson}>download data as json</button>\r\n          <button onClick={sendToDB}>push to database</button> */}\r\n          <button\r\n            style={{ color: isStreaming ? \"red\" : \"orange\" }}\r\n            onClick={streamToDB}\r\n          >\r\n            DEBUG: toggle stream to database\r\n          </button>\r\n          <button onClick={handleToggleDetect}>\r\n            toggle brightness detection\r\n          </button>\r\n          <br />\r\n          <br />\r\n          <code>debug logging: </code>\r\n          <br />\r\n          <ul>\r\n            {logs.map((v, i) => (\r\n              <li key={i}>{v}</li>\r\n            ))}\r\n          </ul>\r\n\r\n          <br />\r\n          {/* {showPreviews && <Gallery data={data} />} */}\r\n          <VideoRecorder\r\n            videoRef={videoRef}\r\n            triggerRecording={isRecording}\r\n            duration={videoDuration}\r\n            showPreview={showPreviews}\r\n            onComplete={handleVideoComplete}\r\n          />\r\n          {/* possible usage: user (twitter) controlled photo session\r\n      <PhotoRecorder\r\n        videoRef={videoRef}\r\n        showPreview={showPreviews}\r\n        captureDelay={captureDelay}\r\n        isCapturing={isCapturing}\r\n      /> */}\r\n\r\n          <PhotoStream\r\n            videoRef={videoRef}\r\n            showPreview={showPreviews}\r\n            streamDelay={streamDelay}\r\n            isStreaming={isStreaming}\r\n          />\r\n          <br />\r\n          <h3>local state:</h3>\r\n          {JSON.stringify(localStateMonitor, null, 2)}\r\n\r\n          <h3>db state</h3>\r\n          {JSON.stringify(dbCommands, null, 2)}\r\n        </div>\r\n      ) : null}\r\n\r\n      <BrightnessDetector\r\n        videoRef={videoRef}\r\n        isDetecting={isDetecting}\r\n        delay={DELAY}\r\n        onDetect={(v) => setIsDay(v.bright)}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CameraComponent;\r\n","import React, { Component } from \"react\";\r\nimport logo from \"./logo.svg\";\r\nimport \"./App.css\";\r\n\r\nimport RiceCam from \"./components/RiceCam\";\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <p>v1.4</p>\r\n        <br />\r\n        <RiceCam />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}