{"version":3,"sources":["components/Camera/Show.module.css","logo.svg","components/customHooks/useInterval.js","components/Camera/Camera.js","components/Camera/index.js","components/Database/lib/firebase.js","components/Database/index.js","components/MediaRecorder/VideoRecorder.js","components/MediaRecorder/index.js","components/BrightnessPredictor/helpers/index.js","components/BrightnessPredictor/index.js","components/BrightnessPredictor/BrightnessDetector.js","components/RiceCam/index.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","gallery","__webpack_require__","p","useInterval","callback","delay","savedCallback","useRef","useEffect","current","id","setInterval","clearInterval","SETTINGS","width","height","facingMode","WebcamComponent","_ref","onRef","webcamRef","_useState","useState","_useState2","Object","slicedToArray","cameraReady","setCameraReady","setupCamera","_ref2","asyncToGenerator","regenerator_default","a","mark","_callee","e1","wrap","_context","prev","next","navigator","mediaDevices","getUserMedia","_this","setState","error_messages","video","onloadedmetadata","stop","apply","this","arguments","react_default","createElement","react_webcam_default","audio","ref","screenshotFormat","videoConstraints","Camera","config","apiKey","process","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","reactConfig","keys","map","v","concat","firebase","apps","length","initializeApp","console","log","dayjs","locale","logging","message","timestamp","format","daystamp","firestore","collection","doc","set","merge","then","catch","e","activityMonitor","convertToObject","browserStorage","estimate","mem","ram","connection","connectionSpeed","battery","batteryLevel","performance","output","input","showFunction","obj","storage","sent","usage","quota","percent","toFixed","window","memory","deviceMemory","mozConnection","webkitConnection","msConnection","effectiveType","getBattery","level","network","browserMemory","objectSpread","totalJSHeapSize","jsHeapSizeLimit","comment","status","_x","grabListOfVideoPaths","_ref3","_callee4","day","_context4","get","_ref4","_callee3","querySnapshot","_context3","forEach","_ref5","_callee2","url","_context2","data","push","getDownloadURL","_x4","abrupt","Promise","all","_x3","_x2","ENCODING_TYPES","Record","mimeTypeOptions","videoRef","triggerRecording","duration","onComplete","showPreview","MediaRecorder","isTypeSupported","mimeType","ext","OPTIONS","tag","gUM","videoOut","setVideoOut","_useState3","_useState4","recordDuration","setRecordDuration","_useState5","_useState6","isRecording","_useState7","_useState8","_useState9","_useState10","videoChunk","setVideoChunk","record","makeLink","blob","Blob","type","URL","createObjectURL","out","key","controls","src","href","download","toConsumableArray","recorder","stream","active","_unused","ondataavailable","onstart","setTimeout","start","style","display","listStyleType","overflowX","loadModel","tf","predictBrightness","rgbarray","model","xs","Array","from","inputXS","preds","predict","print","arraySync","isBright","canvas","clrs","flat","res","getContext","getImageData","BrightnessDetector","isDetecting","onDetect","detectionDelay","setDetectionDelay","detect","bright","document","drawImage","PhotoStream","streamDelay","isStreaming","videoWidth","videoHeight","toDataURL","toBlob","b","imgBlob","put","location","path","err","JSON","stringify","pushImageDataToStorage","isWithinTimeRange","end","sH","slice","sM","startTimestamp","hour","minute","eH","eM","endTimestamp","chk1","isAfter","chk2","isBefore","VideoList","toggleRefresh","vlist","setVlist","names","decodeURIComponent","split","Fragment","whiteSpace","fontSize","overflow","i","margin","textAlign","CameraComponent","_ref5$showPreviews","showPreviews","setVideoRef","logs","setLogs","_useState11","_useState12","isDay","setIsDay","handleLog","_useState13","_useState14","setIsDetecting","_useState15","_useState16","setIsRecording","_useState17","_useState18","videoDuration","setVideoDuration","_useState19","_useState20","timer","setTimer","_useState21","_useState22","isRecordingContinuously","setIsRecordingContinuously","_useState23","_useState24","cameraName","setCameraName","_useState25","_useState26","recordIntervalMin","setRecordIntervalMin","t","_useState27","_useState28","dbCommands","setDBCommands","onChange","onSnapshot","handleRecordContinuous","run","setContinuousRecording","setLocalStateMonitor","isContinuouslyRecording","mins","amount","time","timerStart","timerEnd","isTimerSet","videoDurationSec","videoRecordFreqMin","_useState29","nextRecordingTime","_useState30","localStateMonitor","currentState","_useState31","_useState32","_useState33","_useState34","setIsStreaming","debugStreamImages","_useState35","_useState36","refreshVideo","toggleRefreshVideo","_useState37","_useState38","isShowingDebug","toggleIsShowingDebug","videoLengthSec","backgroundColor","components_Camera","padding","color","fontWeight","onClick","disabled","target","value","RiceCam_VideoList","marginBottom","isSupported","RiceCam_PhotoStream","components_MediaRecorder","vidBlob","fileExtension","namePrefix","undefined","l","pushVideoDataToStorage","BrightnessPredictor","App","className","RiceCam","Component","Boolean","hostname","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f0270525.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"gallery\":\"Show_gallery__qu3hA\"};","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { useState, useEffect, useRef } from \"react\";\n\nconst useInterval = (callback, delay) => {\n  const savedCallback = useRef();\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n};\n\nexport default useInterval;\n","import React, { useState, useEffect, useRef } from \"react\";\nimport Webcam from \"react-webcam\";\n\nconst SETTINGS = {\n  width: 1080,\n  height: 1080,\n  facingMode: \"environment\"\n};\n\nconst WebcamComponent = ({ onRef }) => {\n  const webcamRef = useRef();\n  const [cameraReady, setCameraReady] = useState(false);\n  const setupCamera = async () => {\n    // MDN: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      const e1 =\n        \"Browser API navigator.mediaDevices.getUserMedia not available\";\n      this.setState({ error_messages: e1 });\n      throw e1;\n    }\n\n    const video = webcamRef.current.video;\n    video.onloadedmetadata = () => {\n      setCameraReady(true);\n    };\n  };\n\n  useEffect(() => {\n    setupCamera();\n  }, [webcamRef]);\n\n  if (cameraReady) {\n    onRef && onRef(webcamRef);\n  }\n\n  return (\n    <Webcam\n      audio={false}\n      ref={webcamRef}\n      screenshotFormat=\"image/jpeg\"\n      videoConstraints={SETTINGS}\n      height={400}\n      width={400}\n    />\n  );\n};\n\nexport default WebcamComponent;\n","import Camera from \"./Camera\";\nimport Show from \"./Show\";\n\nexport default Camera;\nexport const Gallery = Show;\n","import firebase from \"firebase\";\n\nconst config = {\n  apiKey: process.env.apiKey,\n  authDomain: process.env.authDomain,\n  databaseURL: process.env.databaseURL,\n  projectId: process.env.projectId,\n  storageBucket: process.env.storageBucket,\n  messagingSenderId: process.env.messagingSenderId,\n};\n\nconst reactConfig = {};\nObject.keys(config).map((v) => {\n  reactConfig[v] = process.env[`REACT_APP_${v}`];\n});\n\nif (!firebase.apps.length) {\n  firebase.initializeApp(reactConfig);\n  console.log(\"DATABASE CONNECTED.\");\n}\n\nexport default firebase;\n//module.exports = firebase;\n","import React, { useState, useEffect } from \"react\";\nimport firebase from \"./lib/firebase\";\n\n// timestamps\nimport dayjs from \"dayjs\";\nimport \"dayjs/locale/ja\";\ndayjs.locale(\"ja\");\n\nexport default firebase;\n\nconst PushToFirebase = (databaseRef = \"test\", data, callback) => {\n  firebase\n    .database()\n    .ref(databaseRef)\n    .push(data)\n    .then((v) => callback(v));\n};\n\nconst PushToFirestore = (databaseRef = \"test\", data, callback) => {\n  const db = firebase.firestore();\n  db.collection(databaseRef);\n};\n\nconst sortTimestampArray = (data, latest = false) => {\n  if (latest) return data.sort((prev, next) => dayjs(next) - dayjs(prev));\n  // latest first\n  else return data.sort((prev, next) => dayjs(prev) - dayjs(next)); // earliest first\n};\n\nexport const logging = (message, callback) => {\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\n\n  firebase\n    .firestore()\n    .collection(\"logs\")\n    .doc(daystamp)\n    .collection(\"logs\")\n    .doc(timestamp)\n    .set({ message: message }, { merge: true })\n    .then((v) => {\n      callback && callback(v);\n    })\n    .catch((e) => console.log(\"LOGGING ERROR: \", e));\n};\n\nexport const activityMonitor = async (callback) => {\n  function convertToObject(input, showFunction) {\n    // recursively\n    // https://stackoverflow.com/questions/37733272/convert-dom-object-to-javascript-object\n    let obj = {};\n    for (var p in input) {\n      switch (typeof input[p]) {\n        case \"function\":\n          if (showFunction) obj[p] = `function: ${input[p]}`;\n          break;\n        case \"object\":\n          obj[p] = convertToObject(input[p], showFunction);\n          break;\n        case \"number\":\n          obj[p] = input[p];\n          break;\n        default:\n          obj[p] = input[p];\n      }\n    }\n    return obj;\n  }\n\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\n\n  // browser tab storage\n  let browserStorage;\n  if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n    const estimate = await navigator.storage.estimate();\n    browserStorage = {\n      usage: estimate.usage,\n      quota: estimate.quota,\n      percent: `${((estimate.usage * 100) / estimate.quota).toFixed(0)} used`,\n    };\n  } else {\n    browserStorage = \"browser does not have storage API\";\n  }\n  // js heap size\n  //   This API returns three pieces of data:\n  // jsHeapSizeLimit - The amount of memory (in bytes) that the JavaScript heap is limited to.\n  // totalJSHeapSize - The amount of memory (in bytes) that the JavaScript heap has allocated including free space.\n  // usedJSHeapSize - The amount of memory (in bytes) currently being used.\n  const mem = window.performance.memory || {};\n  // RAM\n  const ram =\n    `${navigator.deviceMemory} GB` ||\n    \"browser does not have deviceMemory API (ram)\";\n  // network speed\n  const connection =\n    navigator.connection ||\n    navigator.mozConnection ||\n    navigator.webkitConnection ||\n    navigator.msConnection;\n  const connectionSpeed = connection\n    ? connection.effectiveType\n    : \"browser does not have connection API\";\n  // battery\n  let battery;\n  if (\"getBattery\" in navigator) {\n    battery = await navigator.getBattery();\n  }\n  const batteryLevel = battery\n    ? battery.level\n    : \"browser does not have battery API\";\n  // general performance\n  // .toJSON() is unreliable, returns custom objects\n  const performance = convertToObject(window.performance, false);\n\n  const output = {\n    storage: browserStorage,\n    ram: ram,\n    network: connectionSpeed,\n    battery: batteryLevel,\n    performance: performance,\n    browserMemory: {\n      ...convertToObject(mem, false),\n      usage: `${(mem.totalJSHeapSize / mem.jsHeapSizeLimit) * 100} percent`,\n      comment:\n        \"units in bytes. percent is percent of allocated browser memory (multiple tabs included)\",\n    },\n  };\n\n  firebase\n    .firestore()\n    .collection(\"logs\")\n    .doc(daystamp)\n    .collection(\"browser performance logs\")\n    .doc(timestamp)\n    .set({ status: output }, { merge: true })\n    .then((v) => {\n      callback && callback(v);\n    })\n    .catch((e) => console.log(\"LOGGING ERROR: \", e));\n};\n\nexport const pushImageDataToStorage = (imgBlob) => {\n  const imgFolder = \"images\";\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\n\n  console.log(\"pushing Image blob: \", imgBlob);\n  firebase\n    .storage()\n    .ref(`${imgFolder}/${timestamp}.png`)\n    .put(imgBlob)\n    .then((res) => {\n      console.log(`image blob pushed to: ${res.ref.location.path}`, res);\n      const path = res.ref.location.path;\n      firebase\n        .firestore()\n        .collection(\"imageURL\")\n        .doc(daystamp)\n        .collection(\"urls\")\n        .doc()\n        .set({ url: path });\n    })\n    .catch((e) => {\n      const err = `pushImageDataToStorage: ERROR ${JSON.stringify(e)}`;\n      console.log(err);\n      logging(err);\n    });\n};\n\nexport const pushVideoDataToStorage = (\n  vidBlob,\n  fileExtension,\n  namePrefix = \"\",\n  onComplete\n) => {\n  const vidFolder = \"videos\";\n  const timestamp = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\n  const daystamp = dayjs().format(\"YYYY-MM-DD\");\n\n  firebase\n    .storage()\n    .ref(`${vidFolder}/${namePrefix}-${timestamp}${fileExtension}`)\n    .put(vidBlob)\n    .then((res) => {\n      console.log(res);\n      console.log(res.ref.location.path);\n      const path = res.ref.location.path;\n      firebase\n        .firestore()\n        .collection(\"videoURL\")\n        .doc(daystamp)\n        .collection(\"urls\")\n        .doc()\n        .set({ url: path })\n        .then((v) => {\n          const l = `pushVideoDataToStorage: COMPLETE video:${vidFolder}/${timestamp}${fileExtension}, ref: ${path}, callback: ${v}`;\n          logging(l, () => console.log(l));\n          onComplete && onComplete();\n        });\n    })\n    .catch((e) => {\n      const err = `pushVideoDataToStorage: ERROR ${JSON.stringify(e)}`;\n      logging(err, () => console.log(err));\n    });\n};\n\nexport const grabListOfVideoPaths = async (day) => {\n  const daystamp = day\n    ? dayjs(day).format(\"YYYY-MM-DD\")\n    : dayjs().format(\"YYYY-MM-DD\");\n\n  console.log(\"grabbing videos from: \", daystamp);\n\n  return await firebase\n    .firestore()\n    .collection(\"videoURL\")\n    .doc(daystamp)\n    .collection(\"urls\")\n    .get()\n    .then(async (querySnapshot) => {\n      let output = [];\n      await querySnapshot.forEach(async (doc) => {\n        // here are your DB video filepaths\n        const url = doc.data().url;\n        // console.log(url);\n\n        output.push(\n          firebase.storage().ref(url).getDownloadURL() // this is an async function\n        );\n      });\n      return Promise.all(output);\n    });\n};\n\n// single call\nexport const pullAppStateFromDB = () => {\n  firebase\n    .firestore()\n    .collection(\"appState\")\n    .doc(\"commands\")\n    .get()\n    .then((doc) => {\n      console.log(doc.data());\n    })\n    .catch((e) => console.log(\"REMOTE DB STATE READ ERROR: \", e));\n};\n\n// listener function\nexport const listenToDBAppState = (onChange) => {\n  return firebase\n    .firestore()\n    .collection(\"appState\")\n    .doc(\"commands\")\n    .onSnapshot((doc) => {\n      onChange && onChange(doc.data());\n      return doc.data();\n    });\n};\n// notify function\nexport const reportAppStatetoDB = (currentState) => {\n  firebase\n    .firestore()\n    .collection(\"appState\")\n    .doc(\"currentState\")\n    .set(currentState, { merge: true })\n    .then((v) => console.log(\"REMOTE STATE UPDATER: complete. \", v))\n    .catch((e) => console.log(\"REMOTE DB STATE UPDATE ERROR: \", e));\n};\n\nexport const FireStoreState = ({\n  collection = \"appState\",\n  doc = \"commands\",\n  onUpdate,\n}) => {\n  const [dbState, setDBState] = useState({});\n\n  useEffect(() => {\n    firebase\n      .collection(collection)\n      .doc(doc)\n      .onSnapshot((snapshot) => {\n        setDBState(snapshot.data());\n      });\n    return () => setDBState({});\n  }, []);\n\n  useEffect(() => {\n    if (onUpdate) onUpdate(dbState);\n  }, [dbState]);\n\n  return <p>db state: {JSON.stringify(dbState, null, 2)}</p>;\n};\n\nconst deleteImageDataFromDBRecords = () => {\n  // delete by timestamp based on prediction\n  const imgCollection = \"imageData\";\n};\n\nconst createVideoFromDBRecords = () => {\n  // pull in data from DB and construct video\n  const imgCollection = \"imageData\";\n  const predCollection = \"\";\n};\n\nconst getPredictionsFromDB = () => {\n  // predictions should return together with the references UID from imageData\n  // as well as timestamp\n  const collectionName = \"predictions\";\n};\n","import React, { useState, useEffect, useRef } from \"react\";\nimport { logging } from \"../Database\";\n\nexport const ENCODING_TYPES = [\n  \"video/webm;codecs=vp9\",\n  \"video/webm;codecs=vp8\",\n  \"video/mp4\",\n  \"video/H264\",\n  \"video/quicktime\",\n];\n\nconst VideoRecorder = ({\n  videoRef,\n  triggerRecording,\n  duration,\n  onComplete,\n  showPreview,\n}) => {\n  let mimeTypeOptions;\n  if (MediaRecorder.isTypeSupported(\"video/webm;codecs=vp9\")) {\n    mimeTypeOptions = { mimeType: \"video/webm; codecs=vp9\", ext: \".webm\" };\n  } else if (MediaRecorder.isTypeSupported(\"video/webm;codecs=vp8\")) {\n    mimeTypeOptions = { mimeType: \"video/webm; codecs=vp8\", ext: \".webm\" };\n  } else if (MediaRecorder.isTypeSupported(\"video/mp4\")) {\n    mimeTypeOptions = { mimeType: \"video/mp4\", ext: \".mp4\" };\n  } else if (MediaRecorder.isTypeSupported(\"video/H264\")) {\n    mimeTypeOptions = { mimeType: \"video/H264\", ext: \".mp4\" };\n  } else if (MediaRecorder.isTypeSupported(\"video/quicktime\")) {\n    mimeTypeOptions = { mimeType: \"video/quicktime\", ext: \".mov\" };\n  }\n  const OPTIONS = {\n    ...mimeTypeOptions,\n    tag: \"video\",\n    gUM: { video: true, audio: true },\n  };\n  const [videoOut, setVideoOut] = useState(\"\");\n\n  const [recordDuration, setRecordDuration] = useState(5000);\n  useEffect(() => {\n    if (duration && typeof duration === \"number\") setRecordDuration(duration);\n  }, [duration]);\n\n  const [isRecording, setIsRecording] = useState(false);\n  const [videoRecordings, setVideoRecordings] = useState([]);\n  const [videoChunk, setVideoChunk] = useState([]);\n  const ulRef = useRef();\n  useEffect(() => {\n    if (triggerRecording === true && isRecording === false) {\n      logging(\"VideoRecorder: START starting one recording\");\n      record({ duration: recordDuration });\n    }\n  }, [triggerRecording, isRecording]);\n\n  useEffect(() => {\n    // if there is a recording\n    if (videoChunk.length > 0) {\n      console.log(\"making link!\", videoChunk);\n      showPreview && makeLink();\n    }\n  }, [videoChunk]);\n\n  const makeLink = () => {\n    console.log(\"making blob of type\", OPTIONS.mimeType);\n    let blob = new Blob(videoChunk, { type: OPTIONS.mimeType });\n\n    let url = URL.createObjectURL(blob);\n\n    const out = (\n      <li key={url}>\n        <video height={200} controls src={url} />\n        <br />\n        <a\n          href={url}\n          download={`video${OPTIONS.ext}`}\n        >{`download ${`video${OPTIONS.ext}`}`}</a>\n      </li>\n    );\n    setVideoOut([...videoOut, out]);\n  };\n\n  const record = ({ duration = 2000 }) => {\n    if (videoRef) {\n      const stream = videoRef.current.stream;\n      if (!stream.active) {\n        console.log(\"media stream is not active.\", stream);\n      }\n\n      // setup recorder\n      let recorder;\n      try {\n        recorder = new MediaRecorder(stream, {\n          mimeType: OPTIONS.mimeType,\n        });\n      } catch {\n        recorder = new MediaRecorder(stream);\n      }\n      recorder.ondataavailable = (e) => {\n        // when the recording is complete and there is data\n        setVideoChunk([e.data]);\n        if (onComplete) onComplete(e.data, OPTIONS.ext);\n      };\n      recorder.onstart = (e) => {\n        setVideoChunk([]);\n        setTimeout(() => {\n          recorder.stop();\n        }, recordDuration);\n      };\n\n      // run recorder\n      recorder.start();\n    }\n  };\n\n  return (\n    <ul\n      style={{\n        display: \"flex\",\n        listStyleType: \"none\",\n        width: \"100%\",\n        overflowX: \"scroll\",\n      }}\n    >\n      {videoOut}\n    </ul>\n  );\n};\n\nexport default VideoRecorder;\n","import Record from \"./VideoRecorder\";\n\nexport default Record;\n","import * as tf from \"@tensorflow/tfjs\";\n\nconst WIDTH = 12;\nconst HEIGHT = 9;\nconst ARR_LENGTH = 432;\n\nconst loadModel = async () => {\n  return await tf.loadLayersModel(\"assets/model/brightness-predictor.json\");\n};\n\nconst predictBrightness = async rgbarray => {\n  const model = await loadModel();\n\n  if (model) {\n    return await tf.tidy(() => {\n      const xs = [Array.from(rgbarray)];\n      const inputXS = tf.tensor2d(xs, [xs.length, ARR_LENGTH]);\n\n      console.log(inputXS);\n\n      const preds = model.predict(inputXS);\n\n      preds.print();\n\n      const out = preds.arraySync()[0][0];\n\n      return out;\n    });\n  }\n};\n\n// sml model learning bright and dark\nexport const isBright = async canvas => {\n  const clrs = canvas\n    .getContext(\"2d\")\n    .getImageData(0, 0, canvas.width, canvas.height);\n\n  console.log(clrs);\n\n  const flat = clrs.data;\n  const res = await predictBrightness(flat);\n  console.log(res);\n  return res > 0.6 ? true : false;\n};\n\nexport default isBright;\n","import BrightnessDetector from \"./BrightnessDetector\";\n\nexport default BrightnessDetector;\n","import { useState, useEffect } from \"react\";\nimport useInterval from \"../customHooks/useInterval\";\n\nimport { isBright } from \"./helpers\";\n\nconst BrightnessDetector = ({ videoRef, isDetecting, delay, onDetect }) => {\n  // local ML brightness detection\n  const [detectionDelay, setDetectionDelay] = useState(500);\n  useEffect(() => {\n    if (delay && typeof delay === \"number\") setDetectionDelay(delay);\n  }, [delay]);\n\n  useInterval(\n    () => {\n      detect();\n    },\n    isDetecting ? detectionDelay : null\n  );\n  const detect = async () => {\n    if (videoRef) {\n      let context;\n      const video = videoRef.current.video;\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = 12;\n      canvas.height = 9;\n      // TODO: check if canvas is drawing entire image, or is it cut off\n\n      context = canvas.getContext(\"2d\");\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // check brightness\n      const bright = await isBright(canvas);\n      if (onDetect) {\n        onDetect({ bright: bright });\n      }\n    }\n  };\n  return null;\n};\n\nexport default BrightnessDetector;\n","// https://ml5js.org/docs/image-classification-example\n// https://codelabs.developers.google.com/?cat=TensorFlow\n// https://console.firebase.google.com/u/3/project/operation-verde-ricecam/database\n\nimport React, { useState, useEffect } from \"react\";\n// timestamps\nimport dayjs from \"dayjs\";\nimport \"dayjs/locale/ja\";\n\nimport useInterval from \"../customHooks/useInterval\";\nimport Camera from \"../Camera\";\nimport VideoRecorder from \"../MediaRecorder\";\nimport BrightnessDetector from \"../BrightnessPredictor\";\nimport {\n  pushImageDataToStorage,\n  pushVideoDataToStorage,\n  reportAppStatetoDB,\n  listenToDBAppState,\n  grabListOfVideoPaths,\n  logging,\n  activityMonitor,\n} from \"../Database\";\nimport { ENCODING_TYPES } from \"../MediaRecorder/VideoRecorder\";\n\nimport { download, convertToArray, convertToObject } from \"../atoms\";\n\ndayjs.locale(\"ja\");\nconst SCALE = 1;\nconst RGB_SCALE = 0.02;\nconst DETECT_SCALE = 0.02;\nconst STREAM_SCALE = 1;\nconst MONITOR_SCALE = 0.1;\n\nconst PhotoRecorder = ({ videoRef, captureDelay, isCapturing, onRecord }) => {\n  useInterval(\n    () => {\n      capture();\n    },\n    isCapturing ? captureDelay : null\n  );\n\n  const [data, setData] = useState([]);\n  const [rgb, setRGB] = useState([]);\n  const capture = () => {\n    let out = {\n      b64: \"\",\n      rgbArray: [],\n    };\n    if (videoRef) {\n      let context;\n      const video = videoRef.current.video;\n      const canvas = document.createElement(\"canvas\");\n\n      canvas.width = video.videoWidth * SCALE;\n      canvas.height = video.videoHeight * SCALE;\n      // canvas.width = 12;\n      // canvas.height = 9;\n\n      context = canvas.getContext(\"2d\");\n\n      // full res\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // base64 setstate\n      const b64 = canvas.toDataURL();\n      setData([...data, b64]);\n      out.b64 = [...data, b64];\n\n      context.clearRect(0, 0, canvas.width, canvas.height);\n\n      canvas.width = video.videoWidth * RGB_SCALE;\n      canvas.height = video.videoHeight * RGB_SCALE;\n\n      context = canvas.getContext(\"2d\");\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // rgb array (flat)\n      const clrs = context.getImageData(0, 0, canvas.width, canvas.height);\n      console.log(clrs);\n      const flat = convertToArray(clrs.data);\n\n      setRGB([...rgb, flat]);\n      out.rgbArray = [...rgb, flat];\n      // download(JSON.stringify({ data: flat }), \"temp.json\", \"application/json\");\n\n      onRecord && onRecord(out);\n\n      return data;\n    }\n  };\n\n  return <p>capturing: {isCapturing}</p>;\n};\n\nconst PhotoStream = ({ videoRef, streamDelay, isStreaming }) => {\n  useInterval(\n    () => {\n      stream();\n    },\n    isStreaming ? streamDelay : null\n  );\n  const stream = () => {\n    if (videoRef) {\n      let context;\n      const video = videoRef.current.video;\n      const canvas = document.createElement(\"canvas\");\n\n      canvas.width = video.videoWidth * STREAM_SCALE;\n      canvas.height = video.videoHeight * STREAM_SCALE;\n      context = canvas.getContext(\"2d\");\n\n      // full res\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // preview\n      // base64 setstate\n      const b64 = canvas.toDataURL();\n      // setData([...data, b64]);\n\n      // blob it to send to db\n      // blobbing takes a long time therefore there is a callback\n      canvas.toBlob((b) => {\n        console.log(b);\n        pushImageDataToStorage(b);\n      });\n    }\n  };\n\n  return <p> DEBUG: photo streaming: {`${isStreaming}`}</p>;\n};\n\nconst isWithinTimeRange = (start, end) => {\n  console.log(start, end);\n  if (!start || !end) return false;\n  const timestamp = dayjs();\n  const sH = start.slice(0, 2);\n  const sM = start.slice(2);\n  const startTimestamp = dayjs().hour(sH).minute(sM);\n\n  const eH = end.slice(0, 2);\n  const eM = end.slice(2);\n  const endTimestamp = dayjs().hour(eH).minute(eM);\n\n  const chk1 = timestamp.isAfter(startTimestamp);\n  const chk2 = timestamp.isBefore(endTimestamp);\n  const res = chk1 && chk2;\n\n  return res;\n};\n\nconst Timer = ({ start, end, onDetect }) => {\n  if (!start || !end) return \"null timer\";\n  const timestamp = dayjs();\n  const sH = start.slice(0, 2);\n  const sM = start.slice(2);\n  const startTimestamp = dayjs().hour(sH).minute(sM);\n\n  const eH = end.slice(0, 2);\n  const eM = end.slice(2);\n  const endTimestamp = dayjs().hour(eH).minute(eM);\n\n  const chk1 = timestamp.isAfter(startTimestamp);\n  const chk2 = timestamp.isBefore(endTimestamp);\n  const res = chk1 && chk2;\n\n  res && onDetect && onDetect(res);\n\n  return (\n    <div>\n      <h3>timer: </h3>\n      <p>now: {timestamp.format(\"HH:mm\")}</p>\n      <p>start: {startTimestamp.format(\"HH:mm\")}</p>\n      <p>end: {endTimestamp.format(\"HH:mm\")}</p>\n      <p>recording allowed? : {`${res}`}</p>\n    </div>\n  );\n};\n\nconst VideoList = ({ toggleRefresh }) => {\n  // list videos from db\n  const [vlist, setVlist] = useState([]);\n  const hydrateList = () =>\n    grabListOfVideoPaths().then((v) => {\n      setVlist(v);\n    });\n\n  useEffect(() => {\n    hydrateList();\n  }, [toggleRefresh]);\n\n  const names = vlist.map((v) =>\n    decodeURIComponent(v.split(\"/videos%2F\")[1].split(\"?alt\")[0])\n  );\n\n  return (\n    <>\n      <h3>current list of videos today ({vlist.length}): </h3>\n      <ol\n        style={{\n          whiteSpace: \"nowrap\",\n          fontSize: \"0.5rem\",\n          height: 300,\n          overflow: \"scroll\",\n        }}\n      >\n        {vlist.map((v, i) => {\n          return (\n            <li key={i} style={{ margin: \"5px 0\", textAlign: \"left\" }}>\n              <a href={v}>{names[i]}</a>\n            </li>\n          );\n        })}\n      </ol>\n    </>\n  );\n};\n\nconst CameraComponent = ({ showPreviews = false }) => {\n  const [videoRef, setVideoRef] = useState();\n  const [logs, setLogs] = useState([]);\n  const [isDay, setIsDay] = useState(true);\n  // log messages\n  const handleLog = (message) => {\n    setLogs((prev) => [...prev.slice(-4), message]);\n    console.log(\"LOGGER message: \", message);\n    logging(message, (v) => console.log(\"LOGGER: completed. \", v));\n  };\n  // log browser status\n  const ACTIVITY_MONITOR_INTERVAL = 60000;\n  useInterval(() => {\n    console.log(\"logging browser performance\");\n    activityMonitor();\n  }, ACTIVITY_MONITOR_INTERVAL);\n\n  // local ML brightness detector\n  const [isDetecting, setIsDetecting] = useState(false);\n  const DELAY = 1000;\n\n  // video recorder\n  const [isRecording, setIsRecording] = useState(false);\n  const [videoDuration, setVideoDuration] = useState(5000);\n  const [timer, setTimer] = useState({ start: null, end: null });\n  const [isRecordingContinuously, setIsRecordingContinuously] = useState(false);\n  const [cameraName, setCameraName] = useState(\"\");\n  const EVERY_N_MINS = 5;\n  const [recordIntervalMin, setRecordIntervalMin] = useState(EVERY_N_MINS);\n  useInterval(\n    () => {\n      const t = dayjs().format(\"YYYY-MM-DDTHH:mm:ss:SSS\");\n\n      if (!isRecording && isWithinTimeRange(timer.start, timer.end)) {\n        handleLog(`recording video at ${t}`);\n        console.log(\n          \"within timer?? \",\n          isWithinTimeRange(timer.start, timer.end)\n        );\n        setIsRecording(true);\n      } else {\n        handleLog(\"recording still underway, not setting recording to true\");\n      }\n    },\n    isRecordingContinuously ? recordIntervalMin * 60000 : null\n  );\n\n  // listen to DB commands (remote)\n  const [dbCommands, setDBCommands] = useState({});\n  useEffect(() => {\n    if (videoRef) {\n      console.log(\"listening to DB!\");\n      listenToDBAppState(setDBCommands);\n    }\n  }, [videoRef]);\n  // set commands according to db\n  const handleSetVideoDuration = (amount) => {\n    handleLog(\n      `setting recording duration to ${dbCommands.videoDurationSec} secs`\n    );\n    setVideoDuration(amount);\n  };\n  const handleSetVideoRecordFrequency = (mins) => {\n    handleLog(\n      `setting recording interval to ${dbCommands.videoRecordFreqMin} mins`\n    );\n    setRecordIntervalMin(mins);\n  };\n  const handleSetTimer = (time) => {\n    handleLog(`setting timers to ${JSON.stringify(time)}`);\n    if (time.start && time.end) {\n      setLocalStateMonitor((p) => ({\n        ...p,\n        isTimerSet: true,\n      }));\n      setTimer(time);\n    }\n  };\n  const handleRecordOnce = (run) => {\n    handleLog(`recording video once`);\n    setLocalStateMonitor((p) => ({\n      ...p,\n      isRecording: true,\n    }));\n    setIsRecording(true);\n  };\n  const handleRecordContinuous = (run) => {\n    if (run) {\n      handleLog(\n        `setting continuous recording to ${dbCommands.setContinuousRecording}`\n      );\n      setLocalStateMonitor((p) => ({\n        ...p,\n        isContinuouslyRecording: true,\n        isRecording: true,\n      }));\n      setIsRecording(true);\n      setIsRecordingContinuously(true);\n    } else {\n      handleLog(\n        `setting continuous recording to ${dbCommands.setContinuousRecording}`\n      );\n      setLocalStateMonitor((p) => ({\n        ...p,\n        isContinuouslyRecording: false,\n        isRecording: false,\n      }));\n      setIsRecording(false);\n      setIsRecordingContinuously(false);\n    }\n  };\n  useEffect(() => {\n    if (dbCommands) {\n      handleLog(`commands received: ${JSON.stringify(dbCommands)}`);\n      if (\n        timer.start !== dbCommands.timerStart ||\n        timer.end !== dbCommands.timerEnd\n      ) {\n        handleSetTimer({\n          start: dbCommands.timerStart,\n          end: dbCommands.timerEnd,\n        });\n      }\n      if (isRecordingContinuously !== dbCommands.setContinuousRecording) {\n        handleRecordContinuous(dbCommands.setContinuousRecording);\n      }\n      if (videoDuration !== dbCommands.videoDurationSec) {\n        handleSetVideoDuration(dbCommands.videoDurationSec);\n      }\n      if (recordIntervalMin !== dbCommands.videoRecordFreqMin) {\n        handleSetVideoRecordFrequency(dbCommands.videoRecordFreqMin);\n      }\n    }\n  }, [dbCommands]);\n\n  // push local state to DB\n  const [localStateMonitor, setLocalStateMonitor] = useState({\n    isContinuouslyRecording: null,\n    isRecording: null,\n    isTimerSet: null,\n    nextRecordingTime: null,\n  });\n  useEffect(() => {\n    reportAppStatetoDB(localStateMonitor);\n  }, [localStateMonitor]);\n\n  // --------\n  // TESTING\n  // --------\n  // db streaming for images\n  const [streamDelay, setStreamDelay] = useState(100);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const streamToDB = () => {\n    // toggle\n\n    if (!isStreaming) {\n      handleLog(\"streaming images to database!\");\n      // setStreamDelay(100);\n      setIsStreaming(true);\n    } else {\n      handleLog(\"image streaming stopped!\");\n      setIsStreaming(false);\n      // setStreamDelay(1000);\n    }\n  };\n  const handleStreamToDB = (run) => {\n    if (run) {\n      handleLog(\"DEBUG: streaming images to database!\");\n      // setStreamDelay(100);\n      setIsStreaming(true);\n    } else {\n      handleLog(\"DEBUG: stopping image stream!\");\n      setIsStreaming(false);\n    }\n  };\n  useEffect(() => {\n    if (dbCommands) {\n      if (isStreaming !== dbCommands.debugStreamImages) {\n        handleStreamToDB(dbCommands.debugStreamImages);\n      }\n    }\n  }, [dbCommands]);\n\n  // const handleRecord1Hour = () => {\n  //   const OneHourInMS = 3600000;\n  //   setIsRecording(true);\n  //   setIsRecordingContinuously(true);\n  //   setTimeout(() => {\n  //     setIsRecordingContinuously(false);\n  //   }, OneHourInMS);\n  // };\n\n  const handleToggleDetect = () => {\n    setIsDetecting(!isDetecting);\n  };\n\n  const [refreshVideo, toggleRefreshVideo] = useState(false);\n  const handleVideoComplete = (vidBlob, ext) => {\n    console.log(cameraName, vidBlob);\n    pushVideoDataToStorage(vidBlob, ext, cameraName, () =>\n      toggleRefreshVideo((p) => !p)\n    );\n    setLocalStateMonitor((p) => ({ ...p, isRecording: false }));\n    setIsRecording(false);\n  };\n\n  useEffect(() => {\n    if (videoRef) {\n      const video = videoRef.current.video;\n      video.height = video.videoHeight * MONITOR_SCALE;\n      video.width = video.videoWidth * MONITOR_SCALE;\n      console.log(videoRef.current.video);\n    }\n  }, [videoRef]);\n\n  const [isShowingDebug, toggleIsShowingDebug] = useState(false);\n\n  const videoLengthSec = dbCommands.videoDurationSec / 1000;\n\n  return (\n    <div\n      style={{\n        backgroundColor: isDay ? \"white\" : \"#282c34\",\n        width: \"100%\",\n        overflowX: \"hidden\",\n      }}\n    >\n      <Camera onRef={setVideoRef} />\n\n      <br />\n\n      {!cameraName ? (\n        <h3>please select a camera</h3>\n      ) : (\n        <div style={{ textAlign: \"left\", padding: \"0 10px\" }}>\n          <small>\n            select <strong style={{ color: \"gray\" }}>'record 1 video'</strong>{\" \"}\n            to test that the camera is recording properly. If it does, your new\n            video should show up on the 'current list of videos today' section.\n            <br />\n            <br />\n            When you are ready, press the <strong>\n              'record indefinitely'\n            </strong>{\" \"}\n            button.\n          </small>\n        </div>\n      )}\n\n      <br />\n      {isRecording && <h3 style={{ color: \"red\" }}>recording...</h3>}\n\n      <code>recording options: </code>\n      <br />\n      <button\n        style={{\n          color: isRecording && \"red\",\n          padding: \"5px 10px\",\n          fontWeight: \"bold\",\n        }}\n        onClick={handleRecordOnce}\n        disabled={!cameraName}\n      >\n        record 1 video {!!videoLengthSec && `(${videoLengthSec} sec)`}\n      </button>\n      {/* <button onClick={handleRecord1Hour}>\n        record 5 sec videos for 1 hour\n      </button> */}\n      <button\n        onClick={handleRecordContinuous}\n        style={{\n          color: isRecordingContinuously && \"red\",\n          padding: \"5px 10px\",\n          fontWeight: \"bold\",\n        }}\n        disabled={!cameraName}\n      >\n        record indefinitely\n      </button>\n      <select\n        onChange={(e) => {\n          console.log(e.target.value + \" selected\");\n          setCameraName(e.target.value);\n        }}\n        style={{\n          padding: \"5px 10px\",\n          fontWeight: \"bold\",\n          color: cameraName ? \"black\" : \"red\",\n        }}\n      >\n        <option style={{ color: \"red\" }} value=\"\">\n          PLEASE SELECT CAMERA\n        </option>\n        <option value=\"CAM 01\">CAM 01</option>\n        <option value=\"CAM 02\">CAM 02</option>\n      </select>\n      <br />\n      <VideoList toggleRefresh={refreshVideo} />\n\n      <br />\n\n      <button\n        onClick={() => toggleIsShowingDebug((p) => !p)}\n        style={{ padding: \"5px 10px\", marginBottom: 30 }}\n      >\n        Toggle Show Debug\n      </button>\n\n      {isShowingDebug ? (\n        <div>\n          <code>debug buttons: </code>\n          <br />\n          {/* <button onClick={captureOne}>capture</button>\n          <button onClick={capture5sec}>capture5sec</button>\n          <button onClick={capture5secvideo}>capture5sec video</button>\n          <button onClick={downloadAsJson}>download data as json</button>\n          <button onClick={sendToDB}>push to database</button> */}\n          <button\n            style={{ color: isStreaming ? \"red\" : \"orange\" }}\n            onClick={streamToDB}\n          >\n            DEBUG: toggle stream to database\n          </button>\n          <button onClick={handleToggleDetect}>\n            toggle brightness detection\n          </button>\n          <br />\n          <br />\n          <code>debug logging: </code>\n          <br />\n          <ul>\n            {logs.map((v, i) => (\n              <li key={i}>{v}</li>\n            ))}\n          </ul>\n          <br />\n          <code>browser supported video types</code>\n          <ul>\n            {ENCODING_TYPES.map((type) => {\n              const isSupported = MediaRecorder.isTypeSupported(type);\n              return (\n                <li key={type}>\n                  {type} : {isSupported ? \"supported\" : \"not supported\"}\n                </li>\n              );\n            })}\n          </ul>\n          <br />\n          {/* {showPreviews && <Gallery data={data} />} */}\n          <PhotoStream\n            videoRef={videoRef}\n            showPreview={showPreviews}\n            streamDelay={streamDelay}\n            isStreaming={isStreaming}\n          />\n          <br />\n          <h3>local state:</h3>\n          {JSON.stringify(localStateMonitor, null, 2)}\n          <h3>db state</h3>\n          {JSON.stringify(dbCommands, null, 2)}\n        </div>\n      ) : null}\n\n      <VideoRecorder\n        videoRef={videoRef}\n        triggerRecording={isRecording}\n        duration={videoDuration}\n        showPreview={showPreviews}\n        onComplete={handleVideoComplete}\n      />\n\n      {/* possible usage: user (twitter) controlled photo session\n      <PhotoRecorder\n        videoRef={videoRef}\n        showPreview={showPreviews}\n        captureDelay={captureDelay}\n        isCapturing={isCapturing}\n      /> */}\n      <BrightnessDetector\n        videoRef={videoRef}\n        isDetecting={isDetecting}\n        delay={DELAY}\n        onDetect={(v) => setIsDay(v.bright)}\n      />\n    </div>\n  );\n};\n\nexport default CameraComponent;\n","import React, { Component } from \"react\";\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\n\nimport RiceCam from \"./components/RiceCam\";\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <p>v1.6</p>\n        <br />\n        <RiceCam />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}